<?php

namespace Framework\Routing;

use Composer\Autoload\ClassLoader;
use Framework\Http\HttpMethod;
use RuntimeException;

class RouterCache
{
    private const CACHE_HEADER = <<<'PHP'
<?php
// Auto-generated route cache file
// Created: %s
// Do not edit this file manually

return %s;
PHP;

    private ?ClassLoader $composerClassLoader = null;

    public function __construct(
        private readonly string $cacheFile,
        private readonly string $actionsPath
    ) {
        // Composer ClassLoader initialisieren
        $this->initializeComposerClassLoader();
    }

    /**
     * Initialisiert den Composer ClassLoader
     */
    private function initializeComposerClassLoader(): void
    {
        $autoloadFile = $this->findComposerAutoloadFile();

        if ($autoloadFile && file_exists($autoloadFile)) {
            $this->composerClassLoader = require $autoloadFile;
        }
    }

    /**
     * Findet die Composer autoload.php Datei
     */
    private function findComposerAutoloadFile(): ?string
    {
        $possiblePaths = [
            // Standard Composer Setup
            __DIR__ . '/../../vendor/autoload.php',
            // Alternative Pfade
            __DIR__ . '/../../../autoload.php',
            dirname(__DIR__, 3) . '/autoload.php'
        ];

        foreach ($possiblePaths as $path) {
            if (file_exists($path)) {
                return $path;
            }
        }

        return null;
    }

    /**
     * Lädt Routes aus Cache oder erstellt neuen Cache
     * @deprecated Use loadRouteEntries() for consistency with existing API
     */
    public function getRoutes(): array
    {
        return $this->loadRouteEntries();
    }

    /**
     * Lädt RouteEntry-Objekte (Hauptmethode für Router)
     */
    public function loadRouteEntries(): array
    {
        if (!$this->shouldRebuildCache()) {
            return $this->loadFromCache();
        }

        $routes = $this->buildRoutes();
        $this->saveToCache($routes);

        return $routes;
    }

    /**
     * Bestimmt ob Cache neu erstellt werden soll
     */
    private function shouldRebuildCache(): bool
    {
        if (!file_exists($this->cacheFile)) {
            return true;
        }

        // Cache-Datei Timestamp
        $cacheTime = filemtime($this->cacheFile);

        // Actions Verzeichnis prüfen
        if (is_dir($this->actionsPath)) {
            $iterator = new \RecursiveIteratorIterator(
                new \RecursiveDirectoryIterator($this->actionsPath, \RecursiveDirectoryIterator::SKIP_DOTS)
            );

            foreach ($iterator as $file) {
                if ($file->getExtension() === 'php' && filemtime($file) > $cacheTime) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Lädt Routes aus Cache-Datei
     */
    private function loadFromCache(): array
    {
        if (!file_exists($this->cacheFile)) {
            return [];
        }

        $cacheData = require $this->cacheFile;
        if (!is_array($cacheData)) {
            return [];
        }

        // Konvertiere Cache-Arrays zurück zu RouteEntry-Objekten
        return array_map(function (array $data) {
            return new RouteEntry(
                pattern: $data['pattern'],
                methods: array_map(fn(string $method) => HttpMethod::from($method), $data['methods']),
                action: $data['action'],
                middlewares: $data['middlewares'],
                name: $data['name'],
                parameters: $data['parameters'],
            );
        }, $cacheData);
    }

    /**
     * Erstellt Routes durch Scannen der Action-Dateien
     */
    private function buildRoutes(): array
    {
        $routes = [];

        if (!is_dir($this->actionsPath)) {
            return $routes;
        }

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($this->actionsPath, \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->getExtension() !== 'php') {
                continue;
            }

            $className = $this->getClassNameFromFile($file->getPathname());
            if ($className === null) {
                continue;
            }

            // Klasse laden falls noch nicht geladen
            if (!class_exists($className)) {
                continue;
            }

            $reflection = new \ReflectionClass($className);
            $attributes = $reflection->getAttributes(Route::class);

            foreach ($attributes as $attribute) {
                /** @var Route $route */
                $route = $attribute->newInstance();

                $routes[] = new RouteEntry(
                    pattern: $route->getPattern(),
                    methods: $route->getValidatedMethods(),
                    action: $className,
                    middlewares: $route->middlewares,
                    name: $route->name,
                    parameters: $route->getParameters(),
                );
            }
        }

        return $routes;
    }

    /**
     * Modernisierte Methode zum Extrahieren des Klassennamens
     * Nutzt Composer ClassLoader für robuste Klassen-Resolution
     */
    private function getClassNameFromFile(string $file): ?string
    {
        // Methode 1: Composer ClassLoader (Preferred)
        if ($this->composerClassLoader !== null) {
            $className = $this->getClassNameFromComposerClassMap($file);
            if ($className !== null) {
                return $className;
            }
        }

        // Methode 2: PSR-4 Resolution Fallback
        $className = $this->getClassNameFromPsr4($file);
        if ($className !== null) {
            return $className;
        }

        // Methode 3: Legacy File Parsing (Fallback)
        return $this->getClassNameFromFileContent($file);
    }

    /**
     * Klassennamen aus Composer Class Map extrahieren
     */
    private function getClassNameFromComposerClassMap(string $file): ?string
    {
        $realFile = realpath($file);
        if ($realFile === false) {
            return null;
        }

        $classMap = $this->composerClassLoader->getClassMap();

        // Direkte Suche in der Class Map
        foreach ($classMap as $className => $classFile) {
            if (realpath($classFile) === $realFile) {
                return $className;
            }
        }

        return null;
    }

    /**
     * Klassennamen aus PSR-4 Namespace-Regeln ableiten
     */
    private function getClassNameFromPsr4(string $file): ?string
    {
        $realFile = realpath($file);
        if ($realFile === false) {
            return null;
        }

        // PSR-4 Prefix-Verzeichnisse aus Composer
        $prefixDirs = [
            'App\\' => realpath($this->actionsPath . '/..'),
            'Framework\\' => realpath(__DIR__ . '/../../framework'),
        ];

        foreach ($prefixDirs as $prefix => $baseDir) {
            if ($baseDir && str_starts_with($realFile, $baseDir)) {
                $relativePath = substr($realFile, strlen($baseDir) + 1);
                $className = $prefix . str_replace(['/', '.php'], ['\\', ''], $relativePath);

                // Validieren dass die Klasse existiert
                if ($this->validateClassName($className, $file)) {
                    return $className;
                }
            }
        }

        return null;
    }

    /**
     * Legacy Methode: Klassennamen aus Dateiinhalt extrahieren
     */
    private function getClassNameFromFileContent(string $file): ?string
    {
        $content = file_get_contents($file);
        if ($content === false) {
            return null;
        }

        // Namespace extrahieren
        if (!preg_match('/namespace\s+([^;]+);/', $content, $namespaceMatches)) {
            return null;
        }

        // Klassennamen extrahieren
        if (!preg_match('/class\s+(\w+)/', $content, $classMatches)) {
            return null;
        }

        $className = $namespaceMatches[1] . '\\' . $classMatches[1];

        return $this->validateClassName($className, $file) ? $className : null;
    }

    /**
     * Validiert ob Klassenname korrekt ist
     */
    private function validateClassName(string $className, string $file): bool
    {
        // Basis-Validierung
        if (empty($className) || !str_contains($className, '\\')) {
            return false;
        }

        // Prüfen ob es eine Action-Klasse ist
        if (!str_ends_with($className, 'Action')) {
            return false;
        }

        // Prüfen ob die Klasse im App\Actions Namespace ist
        if (!str_starts_with($className, 'App\\Actions\\')) {
            return false;
        }

        return true;
    }

    /**
     * Speichert RouteEntry-Objekte als Arrays in Cache-Datei
     */
    private function saveToCache(array $routes): void
    {
        $cacheDir = dirname($this->cacheFile);
        if (!is_dir($cacheDir) && !mkdir($cacheDir, 0755, true) && !is_dir($cacheDir)) {
            throw new RuntimeException("Cannot create cache directory: {$cacheDir}");
        }

        // Konvertiere RouteEntry-Objekte zu serialisierbaren Arrays
        $cacheData = array_map(function (RouteEntry $route) {
            return [
                'pattern' => $route->pattern,
                'methods' => array_map(fn(HttpMethod $method) => $method->value, $route->methods),
                'action' => $route->action,
                'middlewares' => $route->middlewares,
                'name' => $route->name,
                'parameters' => $route->parameters,
            ];
        }, $routes);

        $content = sprintf(
            self::CACHE_HEADER,
            date('Y-m-d H:i:s'),
            var_export($cacheData, true)
        );

        if (file_put_contents($this->cacheFile, $content, LOCK_EX) === false) {
            throw new RuntimeException("Cannot write to cache file: {$this->cacheFile}");
        }

        // Opcache invalidieren falls aktiv
        if (function_exists('opcache_invalidate')) {
            opcache_invalidate($this->cacheFile, true);
        }
    }

    /**
     * Löscht Cache-Datei
     */
    public function clearCache(): bool
    {
        if (file_exists($this->cacheFile)) {
            return unlink($this->cacheFile);
        }

        return true;
    }

    /**
     * Debug-Methode zum Anzeigen der verwendeten Auflösungsmethode
     */
    public function debugClassResolution(string $file): array
    {
        $results = [
            'file' => $file,
            'composer_available' => $this->composerClassLoader !== null,
            'methods' => []
        ];

        // Composer ClassMap
        if ($this->composerClassLoader !== null) {
            $className = $this->getClassNameFromComposerClassMap($file);
            $results['methods']['composer_classmap'] = $className;
        }

        // PSR-4
        $className = $this->getClassNameFromPsr4($file);
        $results['methods']['psr4'] = $className;

        // Legacy
        $className = $this->getClassNameFromFileContent($file);
        $results['methods']['legacy'] = $className;

        // Final result
        $results['final_result'] = $this->getClassNameFromFile($file);

        return $results;
    }
}